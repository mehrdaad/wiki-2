#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: OpenWrt Boot Process (New OpenWrt)
#+OPTIONS: num:nil H:2



一个boot log的例子:
#+begin_src sh
[    2.602573] VFS: Mounted root (squashfs filesystem) readonly on device 31:2.
[    2.610535] Freeing unused kernel memory: 224K (80428000 - 80460000)
[    3.912151] init: Console is alive
[    3.916056] init: - watchdog -
[    6.994992] init: - preinit -
Press the [f] key and hit [enter] to enter failsafe mode
Press the [1], [2], [3] or [4] key and hit [enter] to select the debug level
Before mount_root
[   10.352510] jffs2: notice: (401) jffs2_build_xattr_subsystem: complete building xattr subsystem, 0 of xdatum (0 unchecked, 0 orphan) and 0 of xref (0 dead, 0 orphan) found.
[   10.369525] mount_root: switching to jffs2 overlay
[   10.540372] procd: - early -
[   10.543495] procd: - watchdog -
[   11.303217] procd: - ubus -
[   12.307928] random: ubusd: uninitialized urandom read (4 bytes read, 53 bits of entropy available)
[   12.439119] procd: - init -
Please press Enter to activate this console.
#+end_src

* Overview
1. Boot
   + Bootloader 比如U-Boot, 配置底层硬件,加载Linux kernel 和 device
     tree blob, 最后传入kernel cmdline跳转到Linux kernel image.
   + 高通的Secure boot会复杂点,先PBL(Primary Boot Loader), 然后
     SBL1(Second BootLoader stage 1) 初始化buses、DDR、clocks等, SBL1
     移交运行控制权给QSEE。QSEE建立安全运行环境，配置xPU，支持fuse, 之
     后才转入APPSBL即为BootLoader, 跳转到HLOS(High LevelOperating
     System) 即为Linux kernel.

2. Kernel init Hareware

   Linux Kernel 将继续初始化外围硬件.

3. Kernel -> Filesystem

   Mount the root filesystem (通过kernel cmdline中的诸如参数 =root==, =rootfstype==).

4. Kernel -> Init Process

   最后kernel启动 =init= 进程 (PID 1).

5. Run preinit

   再procd接管前, preinit会对系统做一些前期的初始工作.

6. Run procd
   
   一旦preinit完成,它将exec procd. 这将用procd取代原来pid1的init进程.
   watchdog的file descriptor不会被关闭, 而是传入到procd进程.

OpenWrt系统从第4步开始. 在OpenWrt系统中, 这个init初始化进程不是普通
Linux中一个初始进程, 而是专为OpenWrt写的一个shell脚本.

* preinit
** =/etc/preinit=
无论Linux什么版本, OpenWrt都会有类似如下的patch,把OpenWrt的init进程放在地一个位置:

#+INCLUDE: "./Files/921-use_preinit_as_init.patch" src c

=/etc/preinit= 如下:

#+begin_src sh
#!/bin/sh
# Copyright (C) 2006 OpenWrt.org
# Copyright (C) 2010 Vertical Communications

[ -z "$PREINIT" ] && exec /sbin/init

export PATH=/usr/sbin:/usr/bin:/sbin:/bin

pi_ifname=
pi_ip=192.168.1.1
pi_broadcast=192.168.1.255
pi_netmask=255.255.255.0

fs_failsafe_ifname=
fs_failsafe_ip=192.168.1.1
fs_failsafe_broadcast=192.168.1.255
fs_failsafe_netmask=255.255.255.0

fs_failsafe_wait_timeout=0

pi_suppress_stderr="y"
pi_init_suppress_stderr="y"
pi_init_path="/usr/sbin:/usr/bin:/sbin:/bin"
pi_init_cmd="/sbin/init"

. /lib/functions.sh
. /lib/functions/preinit.sh
. /lib/functions/system.sh

boot_hook_init preinit_essential
boot_hook_init preinit_main
boot_hook_init failsafe
boot_hook_init initramfs
boot_hook_init preinit_mount_root

for pi_source_file in /lib/preinit/*; do
	. $pi_source_file
done

boot_run_hook preinit_essential

pi_mount_skip_next=false
pi_jffs2_mount_success=false
pi_failsafe_net_message=false

boot_run_hook preinit_main
#+end_src

这里第一行命令是:

#+begin_src sh
[ -z "$PREINIT" ] && exec /sbin/init
#+end_src

=PREINIT= 还没有define, 所以执行 =/sbin/init=. 这个程序来自package
procd.

** =/sbin/init=
package procd中 =init.c= 的main函数基本流程如下:[fn:1]

[[./Files/openwrt_sbin_init.png]]

1. =early()= 

2. =cmdline()=

3. =watchdog_init(1)=

4. =fork=

5. =uloop_init()=

6. =preinit()=

7. =uloop_run()=

** 回到  =/etc/preinit=

* watchdog

* procd

** =STATE_EARLY=

** =STATE_UBUS=

** =STATE_INIT=

** =STATE_RUNNING=






* Reference

=procd/initd/init.c=

#+begin_src c++
int
main(int argc, char **argv)
{
	pid_t pid;

	ulog_open(ULOG_KMSG, LOG_DAEMON, "init");

	sigaction(SIGTERM, &sa_shutdown, NULL);
	sigaction(SIGUSR1, &sa_shutdown, NULL);
	sigaction(SIGUSR2, &sa_shutdown, NULL);

	early();
	cmdline();
	watchdog_init(1);

	pid = fork();
	if (!pid) {
		char *kmod[] = { "/sbin/kmodloader", "/etc/modules-boot.d/", NULL };

		if (debug < 3) {
			int fd = open("/dev/null", O_RDWR);

			if (fd > -1) {
				dup2(fd, STDIN_FILENO);
				dup2(fd, STDOUT_FILENO);
				dup2(fd, STDERR_FILENO);
				if (fd > STDERR_FILENO)
					close(fd);
			}
		}
		execvp(kmod[0], kmod);
		ERROR("Failed to start kmodloader\n");
		exit(-1);
	}
	if (pid <= 0) {
		ERROR("Failed to start kmodloader instance\n");
	} else {
		int i;

		for (i = 0; i < 120; i++) {
			if (waitpid(pid, NULL, WNOHANG) > 0)
				break;
			sleep(1);
			watchdog_ping();
		}
	}
	uloop_init();
	preinit();
	uloop_run();

	return 0;
}
#+end_src



* cc
#+begin_src sh

#+end_src



#+begin_src c++

#+end_src

* Footnotes

[fn:1] https://clockworkbird9.wordpress.com/2016/09/29/openwrtlede-system-boot-sequence/
